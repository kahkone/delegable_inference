#ifndef __IDIGM_MONTGOMERY_MODULAR_ARITHMETIC_H__
#define __IDIGM_MONTGOMERY_MODULAR_ARITHMETIC_H__

#include <iostream>
#include <cassert>

#if IGNORE_CUDA
#define __host__
#define __device__
#endif


typedef unsigned int scalar_t;
typedef unsigned int mont_t;

typedef long int long_signed_t;
typedef unsigned long int long_scalar_t;
typedef unsigned long int long_mont_t;

template <typename P>
__host__ __device__ inline
mont_t montgomery_mul(mont_t x, mont_t y);

template <typename P>
__host__ __device__ inline
mont_t montgomery_mul_host(mont_t x, mont_t y);


/* montgomery_definitions.cpp: generated by batch-gen.py, contains definitions
 * for class encapsulating Montgomery parameters, and for montgomery_mul */
#include "montgomery_definitions.cpp"


template <typename P>
__host__ __device__ inline
mont_t montgomery_reduce(long_mont_t T)
{
    // The first cast below does the same as taking mod 1L<<32
    // The multiplication may overflow, but that just leads to overflowing
    // bits being discarded -- again same as taking mod 1L<<32.
    mont_t m = ((mont_t) T) * P::neg_modulus_inv;
    mont_t t = (mont_t) ((T + (long_mont_t)m * P::modulus) >> 32);
    
    #if DEBUG_ASSERTS
    assert ((P::modulus <= 1U << 31) && (P::modulus > 0));
    assert (
        (T + (long_mont_t)m * P::modulus)
        == ((long_mont_t) t) << 32
    );
    #endif
    
    if (t >= P::modulus)
        t -= P::modulus;
    // t should be < P::modulus, casting to mont_t should be safe
    #if DEBUG_ASSERTS
    assert (t < P::modulus);
    #endif
    return (mont_t) t;
}


template <typename P>
__host__ inline
mont_t montgomery_mul_host(mont_t x, mont_t y)
{
    return montgomery_reduce<P>((long_mont_t)x * y);
}

template <typename P>
__host__ __device__ inline
mont_t montgomery_add(mont_t x, mont_t y)
{
    long_mont_t a { (long_mont_t)x + y };
    if (a >= P::modulus)
        a -= P::modulus;

    #if DEBUG_ASSERTS
    assert (P::modulus < (1L<<31));
    assert (a < P::modulus);
    #endif
    return (mont_t) a;
}

template <typename P>
__host__ __device__ inline
scalar_t mod_neg(scalar_t x)
{
    if (x == 0)
        return x;
    return P::modulus - x;
}

template <typename P>
__host__ __device__ inline
mont_t montgomery_sub(mont_t x, mont_t y)
{
    return montgomery_add<P>(x, mod_neg<P>(y));
}

template <typename P>
__host__ __device__ inline
scalar_t mod_reduce(long_signed_t x)
{
    long_signed_t r { x % P::modulus };
    if (r < 0)
        r += P::modulus;
    // Assuming (0 < P::modulus < 1<<32)
    // then also (0 < r < 1<<32), and casting should be safe
    #if DEBUG_ASSERTS
    assert ((P::modulus < 1L<<32) && (P::modulus > 0));
    #endif
    return (scalar_t) r;
}

template <typename P>
__host__ __device__ inline
mont_t to_montgomery(scalar_t x)
{
    return montgomery_reduce<P>((long_mont_t)x * P::R2_mod_modulus);
}

template <typename P>
__host__ __device__ inline
scalar_t from_montgomery(mont_t x)
{
    return (scalar_t) montgomery_reduce<P>((long_mont_t)x);
}

__host__ __device__ inline 
long_signed_t first_bezout_factor(long_signed_t a, long_signed_t b)
{
    long_signed_t old_s = 1;
    long_signed_t old_t = 0;
    long_signed_t old_r = a;
    long_signed_t s = 0;
    long_signed_t t = 1;
    long_signed_t r = b;
    while(r != 0) {
        long_signed_t q = old_r / r;
        long_signed_t save = old_r;
        old_r = r;
        r = save - q*r;
        save = old_s;
        old_s = s;
        s = save - q*s;
        save = old_t;
        old_t = t;
        t = save - q*t;     
    }
    assert(old_r == 1); // fails if a is not a unit mod b
    return old_s; // a*old_s + b*old_t == old_r
}

template <typename P>
scalar_t mod_inv(scalar_t x)
{
    return mod_reduce<P>(first_bezout_factor(x, P::modulus));
}

template <typename P>
__host__ __device__ inline
mont_t montgomery_zero()
{
    return 0U;
}

template <typename P>
__host__ __device__ inline
mont_t montgomery_one()
{
    return to_montgomery<P>(1U);
}

template <typename P>
__host__ __device__ inline
mont_t montgomery_two()
{
    return to_montgomery<P>(2U);
}

template <typename P>
mont_t montgomery_inv(mont_t x)
{
    long_signed_t b = first_bezout_factor(
        from_montgomery<P>(x), P::modulus
    );
    mont_t x_inv = to_montgomery<P>(mod_reduce<P>(b));
    #if DEBUG_ASSERTS
    assert (montgomery_mul<P>(x_inv, x) == montgomery_one<P>());
    #endif
    return x_inv;
}

template<typename P>
__host__
scalar_t mod_rand()
{
    return mod_reduce<P>(
        (((long_signed_t) rand()) << 30)
        ^ ((long_signed_t) rand())
    );
}

template <typename P>
__host__ __device__
mont_t montgomery_inv_2_pow_k(long_signed_t k)
{
    assert (k >= 0);
    mont_t inv2 = montgomery_inv<P>(montgomery_two<P>());
    mont_t r = montgomery_one<P>();
    for (scalar_t i = 0; i < k; ++i)
        r = montgomery_mul<P>(r, inv2);
    return r;
}




template <typename P>
class Zp {
    mont_t z;
    
public:
    
    static const Zp zero, one;
    static const scalar_t characteristic = P::modulus;
    
    __host__ __device__
    Zp() : z {montgomery_zero<P>()} {}
    
    __host__ __device__
    Zp(scalar_t x) : z {to_montgomery<P>(x)} {}
    
    __host__ __device__
    Zp(const Zp& other) : z {other.z} {}
    
    __host__ __device__
    Zp(scalar_t x, bool no_convert) : z {x} {
        if (!no_convert)
            z = to_montgomery<P>(x);
    }
    
    __host__ __device__
    scalar_t raw() const { return z; }
    __host__ __device__
    scalar_t value() const { return from_montgomery<P>(z); }
    __host__ __device__
    Zp operator-() const { return Zp(mod_neg<P>(z), true); }
    __host__ __device__
    Zp inv() const { return Zp(montgomery_inv<P>(z), true); }
    
    __host__ __device__
    Zp& operator= (const Zp& other) { z = other.z; return *this; }
    __host__ __device__
    Zp& operator+= (const Zp& other) {
        z = montgomery_add<P>(z, other.z); return *this;
    }
    __host__ __device__
    Zp& operator-= (const Zp& other) {
        z = montgomery_sub<P>(z, other.z); return *this;
    }
    __host__ __device__
    Zp& operator*= (const Zp& other) {
        z = montgomery_mul<P>(z, other.z); return *this;
    }
    __host__ __device__
    Zp& operator/= (const Zp& other) {
        z = montgomery_mul<P>(z, montgomery_inv<P>(other.z));
        return *this;
    }
    
    __host__ __device__ 
    friend Zp operator+(Zp l, const Zp& r) { l += r; return l; }   
    __host__ __device__ 
    friend Zp operator-(Zp l, const Zp& r) { l -= r; return l; }   
    __host__ __device__ 
    friend Zp operator*(Zp l, const Zp& r) { l *= r; return l; }
    __host__ __device__ 
    friend Zp operator/(Zp l, const Zp& r) { l /= r; return l; }
    
    __host__ __device__
    friend bool operator== (const Zp& l, const Zp& r) {
        // equality is preserved under to_montgomery
        return l.z == r.z;
    }
    __host__ __device__
    friend bool operator!= (const Zp& l, const Zp& r) {
        // equality is preserved under to_montgomery
        return l.z != r.z;
    }
    __host__ __device__
    friend bool operator>= (const Zp& l, const Zp& r) {
        // relation (>=) is not preserved under to_montgomery
        return l.value() >= r.value();
    }
    __host__ __device__
    friend bool operator> (const Zp& l, const Zp& r) {
        return l.value() > r.value();
    }
    __host__ __device__
    friend bool operator<= (const Zp& l, const Zp& r) {
        return l.value() <= r.value();
    }
    __host__ __device__
    friend bool operator< (const Zp& l, const Zp& r) {
        return l.value() < r.value();
    }
    
    static Zp rand() { return Zp(mod_rand<P>()); }
    static Zp inv_2_pow_k(long_signed_t k) {
        return Zp(montgomery_inv_2_pow_k<P>(k), true);
    }
};

template <typename P> const Zp<P> Zp<P>::zero = Zp<P>(0U);
template <typename P> const Zp<P> Zp<P>::one = Zp<P>(1U);

template <typename P>
std::ostream& operator<<(std::ostream& out, const Zp<P>& s)
{
   return out << "Zp(" << s.value() << ")";
}


#endif  // __IDIGM_MONTGOMERY_MODULAR_ARITHMETIC_H__

